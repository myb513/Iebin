사용자가 인지하는 QoE(Quality-of-Experience)는 
콘텐츠 제공업체 및 전달 시스템의 수익에 영향을 미치기 때문에 
인터넷 비디오 애플리케이션에서 매우 중요합니다.

이러한 조치를 최적화하기 위한 네트워크의 지원이 거의 없다는 점을 감안할 때 
전달 시스템의 어느 곳에서나 병목 현상이 발생할 수 있습니다.

결과적으로 클라이언트 측 플레이어의 강력한 비트 전송률 적응 알고리즘은 
우수한 사용자 경험을 보장하는 데 중요합니다.

이전 연구에서는 최신 상용 솔루션의 주요 한계를 보여주고 다양한 발견적 수정을 제안했습니다.

여러 가지 제안이 나왔음에도 불구하고 여전히 
(1) 이 클라이언트 측 비트 전송률 적응 논리를 가장 잘 설계하는 방법(예: 속도 추정 사용
대 버퍼 점유);


(2) 다양한 운영 체제(예:
높은 처리량 가변성);

에 대한 합의되지 못하고 있습니다.

(3) 실제로 어떻게
다양한 QoE 목표의 균형 조정(예: 시작 지연과 재버퍼링)


이를 위해 이 백서는 세 가지 주요 기술 기여를 합니다.

먼저 이 공간에 약간의 엄격함을 부여하기 위해
에 대해 추론할 수 있는 원칙적인 제어 이론 모델을 개발합니다.
전략의 넓은 스펙트럼.

둘째, 새로운 처리량과 버퍼 점유 정보를 최적으로 결합하여 기존 접근 방식을 능가할 수 있는 모델 예측 제어 알고리즘 제안

셋째, 실제 추적 기반 에뮬레이션을 사용하여 접근 방식을 검증하기 위해 참조 비디오 플레이어에서 실제 구현을 제시


최근의 많은 연구는 다음과 같은 중요한 역할을 강조했습니다.
사용자가 인식하는 QoE(경험 품질)는 인터넷에서 작동합니다.
궁극적으로 수익원에 영향을 미치기 때문에
콘텐츠 제공자를 위해 [24, 35]. 특히 다음과 같은 메트릭
재버퍼링의 지속 시간(즉, 플레이어의 재생 버퍼
렌더링할 콘텐츠가 없음), 시작 지연(즉, 지연
사용자 클릭과 렌더링 시작 시간 사이),
평균 재생 비트 전송률 및 비트 전송률의 가변성
전달하는 것이 핵심 요인으로 떠올랐다.

복잡한 인터넷 영상 전송 생태계와
다양한 병목 현상, 비트 전송률 적응 논리
클라이언트 측 비디오 플레이어에서 최적화하기 위해 중요해짐
사용자 경험 [16]. HTTP 기반 전달 모델에서
오늘날 지배적인 [44] 비디오는 일반적으로 청크되고
다른 비트 전송률 수준으로 인코딩됩니다. 적응형의 목표
비디오 플레이어는 향후 청크에 대한 비트 전송률 수준을 선택하는 것입니다.
가능한 최고의 QoE를 제공합니다. 예: 비트 전송률 최대화
재버퍼링 및 회피 가능성을 최소화하면서
비트 전송률 스위치가 너무 많습니다.

최근의 많은 노력에서 이 적응 논리를 설계하는 데 있어 주요 과제를 지적했으며(예: [46, 17, 32, 34]) 이러한 과제를 해결하기 위해 여러 제안이 나타났습니다(예: [34, 17, 33]). 그러나 수많은 알고리즘의 확산에도 불구하고,
여러 측면에서 이러한 솔루션에 대한 명확성과 합의;
예를 들어 일부에서는 더 나은 처리량 추정을 주장하지만 [47]
다른 사람들은 청크 스케줄링 개선을 제안합니다[34]. 일부 연구자들은
이전 청크 다운로드의 처리량 추정치 및
버퍼 점유 기반 알고리즘의 경우
순전히 버퍼 점유를 기반으로 결정을 내립니다[33].

기본 트레이드오프를 이해하기 위해
다양한 클래스의 알고리즘(예: 속도 기반 대 버퍼 기반)
다양한 운영 체제(예: 낮은 처리량과 높은 처리량 변동성)에서 비디오 비트 전송률을 공식화하여 시작합니다.
확률적 최적 제어 문제로서의 적응. 비디오와 관련된 주요 동적 변수를 공식적으로 정의합니다.
적응 문제와 구체적인 목표. 이 프레임워크를 통해 제어의 더 넓은 디자인 공간을 개략적으로 설명할 수 있습니다.
이 문제에 대한 알고리즘. 우리는 주요 단점을 식별합니다
순수 비율에만 의존하는 기존 접근 방식 또는
버퍼 기반 전략 및 잠재적으로 누락될 수 있음
두 신호를 결합하는 전략에 대해 알아보십시오.

제어 이론 공식에서 얻은 통찰력을 바탕으로 우리는 모델 예측 제어(MPC)[22]가 최적으로 결합할 수 있는 
적합한 알고리즘 클래스라고 주장합니다.
속도 기반 및 버퍼 기반 피드백 신호 모두. 높은 곳에
수준, MPC는 주요 환경 변수를 예측하려고 시도합니다.
움직이는 전망의 지평선을 넘어 예측을 기반으로 정확한 최적화 문제를 해결합니다. 
MPC는 수많은 실제 제어 문제에서 선택되는 기술입니다[22]. 직관적인 공식화 외에도 
복잡한 제어 목표 및 제약 조건을 명시적으로 처리할 수 있습니다.
다음과 같이 잘 이해된 조정 매개변수 세트가 있습니다.
예측의 지평선. 또한 MPC는 다른 질적
고급 제어 방법에 비해 개발 시간이 훨씬 짧고 모델 매개변수를 변경하는 데 
완전한 재설계가 필요하지 않기 때문에 유지 관리가 더 쉽기 때문에 이점이 있습니다.

우리의 맥락에서 MPC 접근 방식은 예측을 수반합니다.
다음 몇 청크에 대한 예상 처리량 및 이를 사용
QoE 최대화를 위한 최적의 비트 전송률 결정을 내립니다. 실제로 시뮬레이션 결과는
최적의 MPC 알고리즘과 예측 오차가 낮았고,
그러면 MPC 방식이 기존의 요율 기반을 능가할 수 있습니다.
및 버퍼 기반 전략.

그러나 실제로 MPC 기반 알고리즘을 실행하는 것은
중요하지 않은 이산 문제를 해결해야 하기 때문에 어렵습니다.
각 시간 단계에서 최적화 문제. 무시해도
계산 오버헤드, 다음과 같은 실제적인 어려움이 있습니다.
이 솔버 로직을 모든 비디오와 함께 번들로 제공해야 할 수도 있습니다.
플레이어 또는 사용자가 추가 다운로드 및 설치를 요구합니다.
소프트웨어. 이러한 문제를 해결하기 위해 간단하면서도 효율적인 FastMPC 메커니즘을 개발합니다. 개념적으로 FastMPC
본질적으로 테이블 열거 접근 방식을 따릅니다.
문제 상태 공간 설명, 특정 인스턴스 해결
최적의 오프라인 상태를 유지하고 최적의 제어 결정을 저장합니다.
미래의 온라인 사용. 그러나 순진하게 구현하면 크기가
이 테이블은 상당한 메모리 오버헤드를 유발할 수 있으며
비디오 플레이어의 시작 지연(예: 추가 JavaScript
로드). 다행히도 간단한 값 비닝 및 압축 전략으로 거의 최적에 가까운 값을 얻을 수 있음을 보여줍니다.
관리 가능한 테이블 크기로 성능을 제공합니다.

오픈 소스 동적 적응 스트리밍 플레이어에서 FastMPC 비트 전송률 적응 알고리즘의 프로토타입을 만들었습니다.
dash.js[1]라고 합니다. 우리가 선택한 플랫폼은 실용적인 것입니다. 참조 오픈 소스 구현입니다.
HTML5 사양을 기반으로 하는 MPEG-DASH 표준용으로 업계 주요 참가자들의 적극적인 지원을 받고 있습니다[7]. 우리는 우리의 구현이 무시할 정도로 추가됨을 보여줍니다.
기본 dash.js 플레이어에 대한 오버헤드. 또한 데모 페이지[14]에서 FastMPC 기반 플레이어를 선보입니다.
실제 측정된 에뮬레이션 실험을 사용하여 알고리즘과 프로토타입 구현을 평가합니다.
10] 및 합성 처리량 가변성 추적. 또한 시뮬레이션 기반 민감도 분석을 통해 이러한 결과를 보완합니다.
다양한 알고리즘 클래스의 성능에 대한 주요 작동 매개변수의 영향을 분석하기 위한 실험.
주요 결과는 다음과 같습니다.

1. 우리가 제안한 MPC 접근 방식이 지속적으로 능가합니다.
중앙 QoE 측면에서 최신 적응 알고리즘은 광대역(FCC) 데이터 세트에서 15%, 셀룰러(HSDPA) 데이터 세트에서 10% 향상되었습니다. 또한 업계 참조 플레이어 dash.js와 비교하여 상당한 개선(60+% QoE 중앙값)을 달성했습니다.

2. 빠르고 낮은 오버헤드 구현 FastMPC는 유사한 CPU 사용량과 60kB의 추가 메모리만 필요로 합니다.
다른 알고리즘과 비교하여 사용.

기여 및 로드맵: 요약하자면 이 백서는
다음과 같은 주요 기여:1
• 공식 제어 이론 모델의 개발
비트레이트 적응 문제(섹션 3);
• 기존 비율 및 버퍼 기반 전략을 포함하는 MPC 접근 방식 설계(섹션 4).
• 실용적이고 빠른 테이블 열거 기반 알고리즘
정확한 MPC 접근 방식의 성능을 거의 최적으로 근사하는 FastMPC(섹션 5)
• 오픈 소스 기반의 낮은 오버헤드 구현
참조 비디오 플레이어 dash.js(섹션 6);
• 다양한 클래스의 알고리즘에 대한 체계적인 평가
광범위한 작동 매개변수와 현실적인
흔적(섹션 7)
다음 섹션에서 DASH에 대한 배경 및 관련 작업에 대해 논의하는 것으로 시작합니다.


이 섹션에서는 수학적 모델을 개발합니다.
HTTP 비디오 스트리밍 프로세스 및 공식적으로 비트 전송률 적응 문제를 정의합니다. 이 모델은 프레임워크를 제공합니다.
기존 알고리즘을 비교 및 ​​평가하고
잠재적인 개선을 위한 기반.

우리는 비디오를 연속적인 비디오 세그먼트 세트로 모델링하거나
청크, V = {1, 2, · · · , K}, 각각은 L 초의 비디오를 포함합니다. 각 청크는 다른 비트 전송률로 인코딩됩니다.
R을 사용 가능한 모든 비트 전송률 수준의 집합이라고 가정합니다. 비디오
플레이어는 비트 전송률 Rk ∈ R에서 청크 k를 다운로드하도록 선택할 수 있습니다.
dk(Rk)를 비트 전송률 Rk에서 인코딩된 청크 k의 크기라고 하자. ~ 안에
고정 비트 전송률(CBR)의 경우, dk(Rk) = L × Rk, 동안
가변 비트레이트(VBR)의 경우 dk ∼ Rk 관계는
청크에 따라 다릅니다.

더 높은 비트 전송률을 선택할수록 더 높은 비디오 품질
사용자가 인지합니다. q(·) : R → R+를 선택한 비트 전송률 Rk를 비디오에 매핑하는 비감소 함수라고 가정합니다.
사용자 q(Rk)가 인식하는 품질. q(·)는
비디오 재생 장치의 콘텐츠뿐만 아니라
동영상. 예를 들어 HDTV 3Mbps 및 1Mbps에서
사용자 경험에 상당한 차이를 초래할 수 있으며, 3Mbps 및 1Mbps의 비디오 품질은 모바일 장치에서 유사할 수 있습니다. 또한 "동적" 청크의 비트 전송률 개선
"정적" 청크를 개선하는 것보다 더 많은 QoE 이득이 발생합니다.

비디오 세그먼트는 재생 버퍼에 다운로드되며,
다운로드했지만 아직 보지 않은 비디오가 포함되어 있습니다. 허락하다
B(t) ∈ [0, Bmax]는 시간 t에서의 버퍼 점유, 즉,
버퍼에 남아있는 비디오의 재생 시간. 버퍼 크기
Bmax는 서비스 제공자의 정책에 따라 달라집니다.
플레이어의 저장 제한으로. 일반적인 플레이어 버퍼
수십 초의 비디오 세그먼트를 보유할 수 있습니다.

그림 2는 의 개념적 작동을 설명하는 데 도움이 됩니다.
비디오 플레이어. 시간 tk에서 비디오 플레이어는 청크 k를 다운로드하기 시작합니다. 이 청크의 다운로드 시간은
dk(Rk)/Ck; 즉, 선택한 청크의 크기에 따라 다릅니다.
비트 전송률 Rk 및 이 다운로드 프로세스 중에 경험한 평균 다운로드 속도 Ck. 일단 청크 k는
완전히 다운로드되면 비디오 플레이어는 ∆tk를 기다리고
시간 tk+1에서 다음 청크 k+1 다운로드를 시작합니다. 우리는 대기 시간 ∆tk가 작고 다음으로 이어지지 않을 것이라고 가정합니다.
버퍼링 이벤트. 시간 t에서 네트워크 처리량을 Ct로 표시하면 다음과 같습니다.

수식 1, 2

버퍼 점유 B(t)는 청크가 다운로드되고 비디오가 재생됨에 따라 진화합니다. 구체적으로,
버퍼 점유는 청크 k 이후 L초만큼 증가합니다.
사용자가 비디오를 시청함에 따라 다운로드되고 감소합니다.2
Bk = B(tk)가 다음과 같은 경우 버퍼 점유를 나타냅니다.
플레이어는 청크 k를 다운로드하기 시작합니다. 버퍼 역학은
다음과 같이 공식화됩니다.

수식 3

여기서 (x)+ = max{x, 0} 표기법은
결코 부정적일 수 없습니다. Bk < dk(Rk)/Ck이면
버퍼는 비디오 플레이어가 여전히 청크 k를 다운로드하는 동안 비어 있게 되어 그림 2와 같이 버퍼링 이벤트가 발생합니다.


2"시작" 단계는 플레이어에 따라 약간 다릅니다.
버퍼를 비우기 전에 일정량의 버퍼가 쌓일 때까지 기다립니다.

대기 시간 ∆tk의 결정, 라고도 함
청크 스케줄링 문제는 멀티 플레이어 비디오의 공정성을 향상시키는 데 똑같이 흥미롭고 중요한 문제입니다.
스트리밍 [34]. 그러나 이 논문에서 우리는 다음과 같이 가정한다.
플레이어는 즉시 청크 k + 1을 다운로드하기 시작합니다.
청크 k가 다운로드될 때. 한 가지 예외는 다음과 같습니다.
버퍼가 가득 차면 플레이어는 버퍼가 다음으로 줄어들 때까지 기다립니다.
청크 k를 추가할 수 있는 수준입니다.

공식 4

4 
Model Predictive Control Approach
for Optimal Bitrate Adaptation

최적의 비트레이트 적응을 위한
모델 예측 제어 접근 방식


이 섹션에서는 비트 전송률 적응을 위한 모델 예측 제어(MPC) 접근 방식의 사례를 만들고 설명합니다.
최적의 결합이 가능한 구체적인 MPC 기반 워크플로우
처리량 예측 및 버퍼 점유. 또한 오류를 더 잘 처리할 수 있는 강력한 MPC 접근 방식을 개발합니다.
매우 가변적인 네트워크 조건에서 처리량 예측에서.


 Why MPC?

첫째, 우리는 MPC의 선택에 대한 직관을 제공합니다.
우리의 설정. MPC가 필요하다고 주장할 수 없습니다.
또는 가능한 모든 제어 알고리즘의 공간에서 최적의 선택입니다. 우리의 목표는 단지 ​​MPC가 자연스러운 것이라고 주장하는 것입니다.
비트 전송률 적응 문제에 적합합니다.


Strawman 솔루션: 이전에 보았듯이 비트 전송률 적응
본질적으로 확률적 최적 제어 문제입니다. 이에
잘 알려진 두 가지 제어 알고리즘 후보가 있습니다. (1) 비례 적분 도함수(PID) 제어 [25]
(2) Markov Decision Process(MDP) 기반 제어[21].
PID는 MPC에 비해 계산이 간단하지만,
시스템을 안정화시키는 역할만 할 뿐이며 QoE 목표를 명시적으로 최적화할 수는 없습니다. 또한 PID 제어는
연속적인 시간 및 상태 공간에서 작동하도록 설계되었으며 우리와 같은 고도로 이산적인 시스템에서 사용하면
성능 저하 또는 불안정 [25]. 또는,
MDP를 사용하면 처리량 공식화를 고려할 수 있습니다.
Markov 프로세스로 버퍼 상태 전환 및 찾기
다음과 같은 표준 알고리즘을 사용하여 최적의 제어 정책
값 반복 또는 정책 반복[21]. 그러나 이것은
처리량 역학이 Markov를 따른다는 강력한 가정
실제 적용되는지 여부는 불분명합니다. 우리는 MDP의 잠재적인 사용과 처리량 분석을 고려합니다.
향후 작업으로서의 역학(섹션 8 참조).

MPC의 경우: 이상적으로는 미래에 대한 완벽한 지식 제공
비디오의 전체 수평선에 대한 처리량 [t1, tK+1],
최적 비트 전송률 R1, · · · , RK 및 시작 지연 Ts는 에 대한 최적화 문제를 해결하여 한 번에 계산할 수 있습니다.
전체 영상 ㅌㅌㅌ
. 실제로 이러한 완벽한
정보가 없기 때문에 그러한 정보를 찾기가 어렵습니다.
오프라인 최적화를 통한 최적의 솔루션
완전한 정보는 미래 전체에 대해 제공되지 않을 수 있지만 합리적으로 정확한 처리량은 가능합니다.
대신 짧은 수평선에 대한 예측을 얻을 수 있습니다.
미래 [tk, tk+N ]. 여기서 직관은 네트워크 상태가 짧은 시간 척도에서 합리적으로 안정적이며 일반적으로
짧은 수평선(수십초) 동안 급격하게 변하지 않는다[51]. 이 통찰력을 기반으로 우리는 이 지평선의 예측을 사용하여 QoE 최적화를 실행할 수 있습니다.
비트 전송률 Rk, 수평선을 [tk+1, tk+N+1] 앞으로 이동합니다.
이 체계는 모델 예측 제어(MPC) 또는
후퇴하는 수평선 제어 [22]. MPC 알고리즘은 널리
산업 제어에서 다양한 영역에서 사용
항해. MPC의 일반적인 이점은 MPC
제약 조건 하에서 동적 시스템에서 복잡한 제어 목표를 온라인으로 최적화하기 위해 예측을 활용할 수 있습니다.

4.2 Basic MPC Algorithm

알고리즘 1은 워크플로에 대한 높은 수준의 개요를 보여줍니다.
비트레이트 적응을 위한 MPC. 우리의 맥락에서 알고리즘은
기본적으로 N 단계 앞서 보고 비트 전송률 Rk를 선택합니다.
(즉, 움직이는 지평선) 특정 QoE 최대화 문제를 해결합니다(이는 플레이어가
정상 또는 시작 단계) 처리량 예측 {Cˆ
t, t ∈
[tk, tk+N ]} 또는 Cˆ
[tk,tk+N ]
. 첫 번째 비트 전송률 Rk는 다음과 같이 적용됩니다.
피드백 정보를 사용하고 최적화 프로세스는
각 단계에서 반복 k.
반복 k에서 플레이어는 움직이는 수평선을 유지합니다.
청크 k ~ k + N -1 및 다음 세 가지 키를 수행합니다.
알고리즘 1과 같이 단계.

1. 예측: 처리량 Cˆ 예측
[tk,tk+N ]
다음 N을 위해
일부 처리량 예측기를 사용하여 청크.
이 논문에서 우리의 목표는 예측 메커니즘을 설계하는 것이 아니라
기존 접근 방식에. 당연히 이 예측의 정확도를 높이면 달성한 이득이 향상됩니다.
MPC를 통해. 즉, MPC는 아래에서 논의하는 것처럼 오류에 강하도록 확장될 수 있습니다.


1: Initialize
2: for k = 1 to K do
3: if player is in startup phase then
4: Cˆ
[tk,tk+N ]= ThroughputPred(C[t1,tk]
)
5: [Rk, Ts] = f
st
mpc 
Rk−1, Bk, Cˆ
[tk,tk+N ]

6: Start playback after Ts seconds
7: else if playback has started then
8: Cˆ
[tk,tk+N ]= ThroughputPred(C[t1,tk]
)
9: Rk = fmpc 
Rk−1, Bk, Cˆ
[tk,tk+N ]

10: end if
11: Download chunk k with bitrate Rk, wait till finished
12: end for

2. 최적화: 이것은 MPC 알고리즘의 핵심입니다.
현재 버퍼 점유 Bk, 이전 비트 전송률 Rk-1
및 처리량 예측 Cˆ
[tk,tk+N ]
, 최적의 비트 전송률 찾기
Rk. 정상 상태에서 Rk = fmpc
Rk−1, Bk, Cˆ
[tk,tk+N ]

,
QOE_MAX _STEADY k+N−1을 해결하여 구현
케이
.
시동 단계에서 시동 시간 T를 다음과 같이 최적화합니다.
[Rk, Ts] = f
성
MPC
Rk−1, Bk, Cˆ
[tk,tk+N ]

, 구현
QOE_MAX k+N−1을 풀어서
케이
. 실용성을 무시한다면
계산 오버헤드에 대한 세부 정보, 우리는 간단히 사용할 수 있습니다.
CPLEX와 같은 기성 솔버를 사용하여 이러한 이산 최적화 문제를 해결할 수 있습니다. 5장에서 살펴보겠지만,
실제로 비디오 플레이어 내에서 최적화 문제를 명시적으로 해결할 필요는 없습니다.

3. 적용: Rk로 청크 k 다운로드를 시작하고 수평선을 앞으로 이동합니다. 
플레이어가 시작 단계에 있으면 재생을 시작하기 전에 Ts를 기다리십시오.

4.3 Robust MPC

기본 MPC 알고리즘은 정확한 처리량 예측기가 존재한다고 가정합니다. 그러나 특정 심각한 net330에서
작업 조건(예: 셀룰러 네트워크 또는 황금 시간대)
인터넷이 혼잡할 때 그러한 정확한 예측자는
사용할 수 없습니다. 예를 들어 예측 변수가 일관되게
처리량을 과대평가하면 높은 재버퍼링이 발생할 수 있습니다. 예측 오류에 대응하기 위해 강력한
MPC 알고리즘.
강력한 MPC는 실제 처리량이 a에서 어떤 값도 취할 수 있다고 가정하고 최악의 경우 QoE를 기본적으로 최적화합니다.
범위 [Cˆ
t, Cˆ
t] 점 추정치 Cˆ와 대조적으로
티. 건장한
MPC는 다음 최적화 문제를 해결하는 것을 수반합니다.
비트 전송률을 얻는 시간 tk Rk = frobustmpc(Rk−1, Bk, [Cˆ
t, Cˆ
티]):
최대
Rk,··· ,Rk+N−1
분
Ct∈[Cˆt,Cˆt]
QoEk+N−1
케이
(15)
성. 제약 조건 (7) ~ (11) (16)
일반적으로 이러한 최대 최소값을 해결하는 것은 간단하지 않을 수 있습니다.
강력한 최적화 문제. 그러나 우리의 특정한 경우에는
우리는 최악의 시나리오가 다음과 같은 경우에 발생한다는 것을 증명할 수 있습니다.
처리량이 하한에 있음 Ct = Cˆ
티. 그래서
강력한 MPC의 구현은 간단합니다. 대신에
씨
t, 우리는 가능한 가장 낮은 Cˆ를 사용합니다.
t는 일반 입력으로
MPC QoE 최대화 문제. 공식적으로,
정리 1. 강력한 MPC 컨트롤러는 다음과 같습니다.
처리량의 하한을 다음과 같이 취하는 일반 MPC
입력, 즉,
Rk = frobustmpc(Rk−1, Bk, [Cˆ
t, Cˆ
티])
= fmpc(Rk−1, Bk, Cˆ
티)
프루프 스케치. 개념적으로 QoE 기능 QoE(R, C)
3항의 합(g1: 총 동영상 품질,
g2: 전체 품질 변화, g3: 버퍼링 시간), 여기서만
버퍼 시간 기간은 처리량 C에 따라 달라집니다. 따라서,
최대
아르 자형
분
C∈[C,C]
QoE(R, C)
≡ 최대
아르 자형

g1(R) - λ × g2(R) - 최대
C∈[C,C]
μ × g3(R, C)
!
≡ 최대
아르 자형
QoE(R, C)
처리량 C의 감소는 더 긴 재버퍼 시간으로 이어지므로 최소 QoE는 C = C에서 달성됩니다.
한 가지 잠재적인 단점은 강력한 MPC가
항상 가장 낮은 처리량을 가정하여 일반 MPC보다 보수적입니다. 여기에서 보수성의 정도는 자연스럽게 하한이 얼마나 느슨한/단단한가에 달려 있습니다. ~ 안에
연습, 우리는 우리의 구현에서 경계로 과거 몇 청크에 대한 최대 예측 오류를 사용하고 그것이
실제로 잘 작동합니다(섹션 7에서 설명).

5 Using MPC in Practice — FastMPC

속도 기반 및 버퍼 기반 알고리즘은 상대적으로
사소한 계산, MPC의 문제는
각 시간 단계에서 이산 최적화 문제를 해결합니다.
여기에는 두 가지 실질적인 문제가 있습니다.

• 계산 오버헤드: 첫째, 높은 계산
MPC의 오버헤드는 로우엔드에서 특히 문제가 됩니다.
대세가 될 것으로 예상되는 모바일
앞으로의 비디오 소비자. 플레이어가 시작하기 전에 비트 전송률 적응 결정 논리가 호출되기 때문에
각 청크를 다운로드할 때 비트 전송률 적응 논리의 과도한 지연은 플레이어의 QoE에 부정적인 영향을 미칩니다.
• 배치: QoE 최대화 문제에 대한 폐쇄형 또는 조합 솔루션이 없기 때문에,
솔버(예: CPLEX 또는 Gurobi)를 사용해야 합니다.
그러나 비디오 플레이어는
이러한 솔버 기능과 함께 번들로 제공됩니다. 예를 들어 라이선스 문제로 인해 그러한 소프트웨어의 배포가 불가능하거나
추가 플러그인 또는 소프트웨어 설치가 필요합니다.
채택에 상당한 장벽이 됩니다[26].

위의 논의에서 해결책은 분명합니다.
우리가 개발하는 것은 가볍고 조합적이어야 합니다(즉,
LP 또는 ILP를 온라인으로 해결하지 않음). 따라서 이 섹션에서 우리는
빠른 개발을 통해 이 두 가지 주요 실제 문제를 해결합니다.
및 어떠한 요구 사항도 요구하지 않는 낮은 오버 헤드 FastMPC 설계
비디오 플레이어의 명시적 솔버 기능 [48].

5.1 High-Level Idea of FastMPC

높은 수준에서 FastMPC 알고리즘은 기본적으로 다음을 따릅니다.
테이블 열거 방식. 여기에서 오프라인 단계를 수행합니다.
상태 공간을 열거하고 각각의 특정 인스턴스를 해결합니다. 그런 다음 온라인 단계에서 현재 작동 조건에 매핑된 이러한 저장된 최적 제어 결정을 사용합니다. 즉, 알고리즘은 간단한
현재에 가장 가까운 키 값으로 인덱싱된 테이블 조회
상태 및 조회의 출력은 다음을 위한 최적의 솔루션입니다.
선택한 구성.
우리의 설정(그림 5)에서 상태 공간은 다음과 같이 결정됩니다.
다음 차원: (1) 현재 버퍼 수준, (2) 선택한 이전 비트 전송률, (3) 예상 처리량
다음 N 청크(즉, 계획 기간). 따라서 FastMPC
각 차원에 대해 다른 값을 캡처하고 최적화를 해결하는 잠재적 시나리오를 열거해야 합니다.
오프라인 문제.
불행히도, 이 아이디어를 직접 사용하는 것은 고차원 상태 공간을 가지고 있기 때문에 매우 비효율적입니다. 예를 들어 버퍼 수준에 대해 100개의 가능한 값이 있는 경우
10개의 가능한 비트 전송률, 크기가 5인 수평선, 1000개의 가능한 처리량 값, 테이블에는 1018개의 행이 있습니다!4
이 큰 상태 공간에는 두 가지 명백한 결과가 있습니다.
첫째, 전체 테이블을 명시적으로 저장하는 것은 실용적이지 않을 수 있습니다.
기억에. 이것은 단지 가상의 관심사가 아니라는 점에 유의하십시오. 이 테이블의 실제 구현이 필요한 경우
dash.js 플레이어 [1] 조회는 매우 높음을 의미합니다.
테이블을 플레이어 모듈에 다운로드해야 하므로 큰 시작 지연과 함께 메모리 풋프린트가 발생합니다. 
둘째,
사소하지 않은 오프라인 계산 비용이 발생할 수 있습니다.
작동 조건이 변경되면 다시 실행해야 합니다.

5.2 Optimizing FastMPC Performance

다음으로, 테이블을 만들기 위한 두 가지 주요 최적화를 제시합니다.
열거 접근이 다루기 쉽습니다.
비닝을 통한 압축: 첫째, 오프라인 탐색 비용을 해결하기 위해 버퍼 및 처리량 수준에 대해 매우 세분화된 값이 필요하지 않을 수 있다는 통찰력이 있습니다. 처럼
결과적으로 이러한 값은 다음과 같이 적절하게 거칠어질 수 있습니다.
집계 쓰레기통. 또한 비닝을 사용하면 필요하지 않습니다.
행 키가 bin 행 인덱스에서 직접 계산되므로 명시적으로 저장합니다. 여기서의 도전은
비닝의 세분성과 최적성 손실의 균형을 유지합니다.
실제로. 실제로, 우리는 버퍼에 100개의 빈을 사용한다는 것을 발견했습니다.
처리량 예측을 위한 레벨 및 100개의 빈이 잘 작동하고
거의 최적의 성능을 제공합니다.
테이블 압축: 두 번째 통찰력은 결정이
오프라인 계산으로 학습된 테이블은 중요한 구조를 갖습니다. 특히, 몇 가지에 대한 최적의 솔루션
유사한 시나리오는 동일할 것입니다. 따라서 비닝 전략과 함께 이 구조를 활용하여 다음을 수행할 수 있습니다.
결정 벡터를 저장하기 위해 runlength 인코딩을 사용하여 간단한 무손실 압축 전략을 탐색합니다. 최적의
그런 다음 이진 검색을 사용하여 온라인으로 결정을 검색할 수 있습니다.
실제로 압축하면 테이블이 차지하는 것을 볼 수 있습니다.
버퍼 레벨을 위한 100개의 빈, 처리량 예측을 위한 100개의 빈 및 5개의 비트 전송률 레벨이 있는 60kB 미만.

6 Implementation

이 섹션에서는 MPC 구현에 대해 설명합니다.
dash.js 프레임워크에서 접근합니다. 우리의 구현
다음과 같이 dash.js 마스터 브랜치(v1.2.0 릴리스)를 기반으로 합니다.
개발 당시에는 안정적인 버전이었습니다. 우리는 우리의 구현이 미래에 쉽게 적응할 수 있다고 믿습니다.
최소한의 수정이 필요한 버전(≈ 800줄
자바스크립트). 소스 코드 및
데모 데모 페이지를 방문하십시오[14].

7 Evaluation


이 섹션에서는 기존 접근 방식과 접근 방식을 비교합니다.
속도 및 버퍼 기반 접근 방식의 조합 사용
실제 플레이어 및 시뮬레이션 실험. 또한 CPU 및 메모리 오버헤드에 대한 마이크로벤치마크를 제시합니다.
FastMPC 구현.

7.1 Setup

주요 매개변수를 설명하는 것으로 시작합니다. (1) 처리량 가변성 추적; (2) 비디오 특정 매개변수; 
(3) 다양한 적응 알고리즘에 대한 구성; (4) 정의
이 섹션 전체에서 사용하는 정규화된 QoE 메트릭입니다.

우리 논문은 최근의 논쟁에 의해 동기가 부여되었습니다.
HTTP(DASH)를 통한 동적 적응 스트리밍 설계
알고리즘. 이 공간에 약간의 엄격함을 부여하기 위해 우리는
제어 이론 문제 공식화를 통해
디자인 공간을 체계적으로 탐색하고 잘 정의된 솔루션을 통해 다양한 솔루션 클래스를 정량적으로 평가합니다.
QoE 메트릭. 더 넓은 디자인의 핵심 통찰력으로
기존 솔루션에 비해 공간이 확보되어 모델 예측 제어 접근 방식을 설계 및 구현했습니다.
사용자의 QoE를 최대화하기 위해 버퍼 점유와 처리량 예측을 최적으로 결합합니다. dash.js를 사용하여 MPC의 실제 구현을 시연했습니다.
참조 비디오 플레이어. 다음을 사용하는 추적 기반 에뮬레이션
현실적인 처리량 가변성 추적은 계산의 무시할 만한 증가로 광범위한 작동 조건에서 최첨단 솔루션에 비해 이점을 확인했습니다.
메모리 요구 사항. 향후 작업으로 더 정확한 처리량 예측을 통합하고 명시적으로
멀티 플레이어 상호 작용을 캡처합니다.